/*
卡拉兹(Callatz)猜想：

对任何一个正整数 n，如果它是偶数，那么把它砍掉一半；如果它是奇数，那么把 (3n+1) 砍掉一半。这样一直反复砍下去，最后一定在某一步得到 n=1。卡拉兹在 1950 年的世界数学家大会上公布了这个猜想，
传说当时耶鲁大学师生齐动员，拼命想证明这个貌似很傻很天真的命题，结果闹得学生们无心学业，一心只证 (3n+1)，以至于有人说这是一个阴谋，卡拉兹是在蓄意延缓美国数学界教学与科研的进展……

我们今天的题目不是证明卡拉兹猜想，而是对给定的任一不超过 1000 的正整数 n，简单地数一下，需要多少步（砍几下）才能得到 n=1？

1005 继续(3n+1)猜想 （25 分）
卡拉兹(Callatz)猜想已经在1001中给出了描述。在这个题目里，情况稍微有些复杂。

当我们验证卡拉兹猜想的时候，为了避免重复计算，可以记录下递推过程中遇到的每一个数。例如对 n=3 进行验证的时候，我们需要计算 3、5、8、4、2、1，则当我们对 n=5、8、4、2 进行验证的时候，
就可以直接判定卡拉兹猜想的真伪，而不需要重复计算，因为这 4 个数已经在验证3的时候遇到过了，我们称 5、8、4、2 是被 3“覆盖”的数。我们称一个数列中的某个数 n 为“关键数”，如果 n 不能被数列中的其他数字所覆盖。

现在给定一系列待验证的数字，我们只需要验证其中的几个关键数，就可以不必再重复验证余下的数字。你的任务就是找出这些关键数字，并按从大到小的顺序输出它们。


输入样例：
6
3 5 6 7 8 11
输出样例：
7 6


这题不知道为什么输出多一个11...
*/



#include <iostream>
#include <vector>
#include <algorithm>
#define MAX  5000

using namespace std;

int cmp(int x,int y)
{
    return x>y;    
}

int main()
{
    //要验证的数
    int N,m=0,i=0,k=0;
    vector<int>V;
    
    cin>>N;
    
    int hash[MAX]={0};
    //将计算过程中产生存起来
    while(N!=1){
        
        hash[N]++;
        
        if(N%2!=0)
            N=3*N+1;
            
        N = N/2;
        
        //hash[N]=1;
        //test
        //cout<<hash[N]<<endl;
        
        k++;
    }
    
    //cout<<k<<endl;

    //存储要比较的数字
    while(cin>>m){
    
        if(hash[m]==0)
            V.push_back(m);
        if(cin.get()=='\n')
            break;
    }
    
    /*
    for(int i=0;i<k;i++){
        if(hash[V[i]]==0){
            
            cout<<V[i]<<" ";
        }
    }
    */
    cout<<endl;
    
    sort(V.begin(),V.end(),cmp);
    
    for(auto it=V.begin();it!=V.end();it++)
        cout<<*it<<" ";
    
    cout<<endl;

    
    return 0;
}
