#include <stdio.h>#include <string.h>#include <stdlib.h>#include <pthread.h>#include <sys/socket.h>#include <netpacket/packet.h>#include <sys/ioctl.h>#include <net/if.h>#include <net/ethernet.h>#include <strings.h>#include <libnet.h>#include <unistd.h>         #include "../pthread/arp_pthread.h"#include "../source/ip_filter.h"#include "../source/ip_link.h"#include "../source/get_interface.h"#include"../pthread/key_pthread.h"#include "../pthread/udp_pthread.h"#include "../source/pos/console.h"#include "types.h"//用户登录void entrance_sys(void){	system("clear");	while(1)	{		system("clear");		char id[20] = "";		char password[20] = "";		write(1,"\e[0m",4);//清除格式		cusor_moveto(25,10);		PRINT( "用户名:", GREEN);		write(1,"\e[7m",4);		fgets(id,sizeof(id),stdin);		id[strlen(id)-1] = '\0';		write(1,"\e[0m",4);		cusor_moveto(25,11);		PRINT( "密  码:", GREEN);		write(1,"\e[7m",4);		fgets(password,sizeof(password),stdin);		password[strlen(password)-1] = '\0';		write(1,"\e[0m",4);		if(strcmp(id,"admin") == 0&&strcmp(password,"111111") == 0)		{						int i =0;			write(1,"\e[7m",4);			for(i=0;i<50;i++)			{				cusor_moveto(10+i,14);				usleep(9000);				printf(" ");			}			write(1,"\e[0m",4);			system("clear");			break;		}		system("clear");		cusor_moveto(25,10);		PRINT( "用户名与密码不匹配！", RED);		cusor_moveto(25,11);		PRINT( "请重新输入", RED);		cusor_moveto(35,11);		sleep(2);		}}/**********************************************************************功能:		销毁线程池，等待队列中的任务不会再被执行，			但是正在运行的线程会一直,把任务运行完后再退出*参数:		线程池句柄*返回值:	成功：0，失败非0*********************************************************************/int pool_uninit(pool_t *pool){	pool_task *head = NULL;	int i;		pthread_mutex_lock(&(pool->queue_lock));	if(pool->destroy_flag)/* 防止两次调用 */		return -1;	pool->destroy_flag = 1;	pthread_mutex_unlock(&(pool->queue_lock));	/* 唤醒所有等待线程，线程池要销毁了 */	pthread_cond_broadcast(&(pool->queue_ready));	/* 阻塞等待线程退出，否则就成僵尸了 */	for (i = 0; i < pool->threads_limit; i++)		pthread_join(pool->threadid[i], NULL);	free(pool->threadid);	/* 销毁等待队列 */	pthread_mutex_lock(&(pool->queue_lock));	while(pool->queue_head != NULL){		head = pool->queue_head;		pool->queue_head = pool->queue_head->next;		free(head);	}	pthread_mutex_unlock(&(pool->queue_lock));	/*条件变量和互斥量也别忘了销毁*/	pthread_mutex_destroy(&(pool->queue_lock));	pthread_cond_destroy(&(pool->queue_ready));		 free(pool);    /*销毁后指针置空是个好习惯*/    pool = NULL;	return 0;}/**********************************************************************功能:		初始化线程池结构体并创建线程*参数:					pool：线程池句柄			threads_limit：线程池中线程的数量			router: 路由器结构体*返回值:	无*********************************************************************/void pool_init(pool_t *pool, int threads_limit,ROU *router){	pool->threads_limit = threads_limit;	pool->queue_head = NULL;	pool->task_in_queue = 0;	pool->destroy_flag = 0;	/*创建存放线程ID的空间*/	pool->threadid = (pthread_t *)calloc(threads_limit, sizeof(pthread_t));		/*初始化互斥锁和条件变量*/	pthread_mutex_init(&(pool->queue_lock), NULL);	pthread_cond_init(&(pool->queue_ready), NULL);	//创建线程	pthread_create(&(pool->threadid[0]), NULL, key_arp_control, router);//终端控制线程	pthread_create(&(pool->threadid[1]), NULL,get_arp_answer,router);//数据包接收转发线程（内含过滤）	pthread_create(&(pool->threadid[2]), NULL, set_arp_req, router);//远程控制线程		return;}void thread_pool(ROU *router){	pool_t pool;	int i = 0;	pool_init(&pool, 3,router);//初始化一个线程池，其中创建3个线程，线程的参数为路由器结构体		pool_uninit(&pool);//删除线程池}int main(int argc,char *argv[]){	getinterface();//接口函数	entrance_sys();//进入系统	ROU router;	router.sockfd = socket(PF_PACKET,SOCK_RAW,htons(ETH_P_ALL));//原始套接字的创建		if(router.sockfd  < 0)//创建失败打印错误信息	{		perror("socket");		exit(-1);	}		thread_pool(&router);//创建线程池并初始化	close(router.sockfd);	return 0;}